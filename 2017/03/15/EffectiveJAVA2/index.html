<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
  <title>Hexo</title>
  <meta name="description" content="" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="MobileOptimized" content="320" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" type="text/css" href="/css/screen.css" />
  <link rel="stylesheet" type="text/css" href="/css/style.css" />
  <meta name="generator" content="Hexo">

  
  
  

  
</head>

<!--
<body class="post-template">
-->
<body class="home-template">
<div id="perspective" class="perspective effect-movedown">
  <div class="container">
    <!-- wrapper -->
    <div class="wrapper">

      <header class="site-head"  style="background: #24282b url(/img/img-bg.jpg) 0 -20%" >
    <div class="vertical">
        <div class="site-head-content inner">
             <a class="blog-logo" href="/"><img src="/img/logo.svg" alt="Blog Logo"/></a> 
            <h1 class="blog-title">Hexo</h1>
            <h2 class="blog-description"><button id="showMenu">Show Menu</button></h2>
        </div>
    </div>
</header>

      

<main class="content" role="main">
  <article class="post">
    <span class="post-meta">
      <time datetime="2017-03-15T02:05:04.106Z" itemprop="datePublished">
          2017-03-15
      </time>
    
</span>
    <h1 class="post-title"></h1>
    <section class="post-content">
      <h1 id="第二章-创建销毁对象"><a href="#第二章-创建销毁对象" class="headerlink" title="第二章 创建销毁对象"></a>第二章 创建销毁对象</h1><h3 id="第一条使用静态工厂方法"><a href="#第一条使用静态工厂方法" class="headerlink" title="第一条使用静态工厂方法"></a>第一条使用静态工厂方法</h3><p> 为了让客户端获取类的实例</p>
<ol>
<li>提供一个公有的构造器</li>
<li>类可以提供一个公有的静态工厂方法<blockquote>
<p>静态工厂方法创建实例有如下优点：</p>
<ol>
<li><p>它有名称，使得代码易读。</p>
</li>
<li><p>不必每次调用他们的时候都创建一个新对象</p>
</li>
<li><p>静态工厂方法与构造器不同的第三大优势在于，他们可以返回原返回类型的任何子类型的对象</p>
</li>
<li><p>在创建参数化类型实例的时候，它们使代码变得更加简洁。</p>
</li>
</ol>
<p>静态工厂方法创建实例有如下缺点：</p>
<ol>
<li><p>类如果不含有公有的或受保护的构造器，就不能被子类化。</p>
</li>
<li><p>它们与其他的静态方法实际上没有任何区别。</p>
</li>
</ol>
<p><strong>valueOf</strong></p>
<p><strong>of_valueOf</strong></p>
<p><strong>getInstance</strong></p>
<p><strong>newInstance</strong></p>
<p><strong>getType</strong></p>
<p><strong>newType</strong></p>
</blockquote>
</li>
</ol>
<h3 id="第二条：遇到多个构造器参数时要考虑用构造器"><a href="#第二条：遇到多个构造器参数时要考虑用构造器" class="headerlink" title="第二条：遇到多个构造器参数时要考虑用构造器"></a>第二条：遇到多个构造器参数时要考虑用构造器</h3><ol>
<li>使用构造器，设置不同的参数，顺序。</li>
<li>使用javabeans模式（阻止了把类变为不可变的可能，需要保证线程安全）</li>
<li>builder模式，让客户端利用所有必要的参数调用构造器，得到一个builder对象，然后客户端在builder对象上调用类似与set的方法，来设置相关的可选参数。—-构建器</li>
<li>使用重叠构造器。</li>
</ol>
<h3 id="第三条：-用私有构造器或者枚举类型强化Singleton属性"><a href="#第三条：-用私有构造器或者枚举类型强化Singleton属性" class="headerlink" title="第三条： 用私有构造器或者枚举类型强化Singleton属性"></a>第三条： 用私有构造器或者枚举类型强化Singleton属性</h3><p><em>Singleton with public final field</em></p>
<pre><code>`public class Elvis{
    public static final Elvis INSTANCE=new Elvis();
    private Elvis(){....}
    public void leaveTheBUilding(){....}
}`
</code></pre><p><em>Singleton with static factory</em></p>
<pre><code>`public class Elvis{
    private static final Elvis INSTANCE=new Elvis();
    private Elvis(){...}
    public static Elvis getInstance(){ return INSTANCE;}
    public void leaveTheBuilding(){...}
}`
</code></pre><blockquote>
<p>对于以上两种方法享有特权的用户可以借助AccessibleObject.setAccessible方法，通过反射机制调用私有构造器。</p>
</blockquote>
<p><em>Enum singleton - the preferred approach实现Singleton的第三种方法</em></p>
<p><strong>最佳实现Singleton方法</strong></p>
<pre><code>`public enum Elvis{
    INSTANCE;
    public void leaveTheBuilding(){...}
}`
</code></pre><h3 id="第四条：通过私有构造器强化不可实例化的能力"><a href="#第四条：通过私有构造器强化不可实例化的能力" class="headerlink" title="第四条：通过私有构造器强化不可实例化的能力"></a>第四条：通过私有构造器强化不可实例化的能力</h3><p>有时，需要编写只包含静态方法和静态域的类，这类工具类不需要进行实例化，可以通过设置一个private私有构造器，它就不能被实例化。但是该方法，使得一个类不能被子类化，所有的构造器都必须是显示或隐式地调用超类构造器，在这种情况下，子类没有可访问的超类构造器可调用了。</p>
<h3 id="第五条：避免创建不必要的对象"><a href="#第五条：避免创建不必要的对象" class="headerlink" title="第五条：避免创建不必要的对象"></a>第五条：避免创建不必要的对象</h3><ol>
<li>使用静态的初始化器</li>
</ol>
<pre><code>`class Person{
    private final Date birthDate;
    //Other fields, methods and constructor omitter
    /**
     *the starting and ending dates of the baby boom.
     */
    private static final Date BOOM_START;
    private static final Date BOOM_END;

    Static{
        Calendar gmtCal=Calendar.getInstance    (TimeZone.getTimeZone(&quot;GET&quot;));
        gmCal.set(1946,Calendar.JANUARY,1,0,0,0);
        BOOM_START=gmCal.getTime();
        gmCal.set(1965,Calendar.JANUARY,1,0,0,0);
        BOOM_END=gmCal.getTime();
    }

    public boolean isBabyBoomer(){
        return birthDate.compareTo(BOOM_START)&gt;=0&amp;&amp;
                birthDate.compareTo(BOOM_END)&lt;0;
    }
}`
</code></pre><p>性能显著提高，，但是改进后的person类被初始化，但是isBabyBoomer方法没有调用，就没必要对静态域进行初始化，可以<em>延迟初始化</em>，但是这样会使得方法变得复杂。</p>
<blockquote>
<ol>
<li><p>要优先使用基本类型而不是装箱基本类型，要当心无意识的自动装箱。</p>
</li>
<li><p>重用对象付出代价要远远大于因创建重复对象而付出的代价。必要时如果没能实施保护性拷贝，将会导致潜在的错误和安全漏洞；而不必要的创建对象则只会影像程序的风格和性能</p>
</li>
</ol>
</blockquote>
<h3 id="第六条：消除过期的对象引用"><a href="#第六条：消除过期的对象引用" class="headerlink" title="第六条：消除过期的对象引用"></a>第六条：消除过期的对象引用</h3><pre><code>`public class Stack{
    private Object[] elements;
    private int size=0;
    private static final int DEFAULT_INITIAL_CAPACITY=16;

    public Stack(){
        elements=new Object[DEFAULT_INITIAL_CAPACITY];
    } 
    public void push(Object e){
        ensureCapacity();
        elements[size++]=e;
    }
    public Object pop(){
        if(size==0)
            throw new EmptyStackException();
        return elements[--size];
    }
    private void ensureCapacity(){
        if(elements.length==size)
            elements=Arrays.copyof(elements, 2 * size+1);
    }
}`
</code></pre><blockquote>
<p>从栈中弹出的对象不会被当作垃圾回收，因为栈内部维护着这些对象的过期引用。</p>
</blockquote>
<pre><code>`public Object pop(){
    if(size==0)
        throw new EmptyStackException();
    Object result=elements[--size];
    elements[size]=null;//Eliminate obsolete reference
    return elements[--size];
}`
</code></pre><blockquote>
<p>清空对象引用应该是一种例外，而不是一种规范行为。消除过期引用最好的方法是让包含该引用的变量结束其生命周期。</p>
</blockquote>
<p><em>只要类是自己管理内存，程序员就应该警惕内存泄漏，一旦元素被释放掉，则该元素中包含的任何引用都应该被清空。</em></p>
<p>###第七条避免使用终结方法</p>
<pre><code>`//try-finally block guarantees execution of termination method
Foo foo=new Foo(....)
try{
    //Do what must be done with foo
    ...
} finally{
    foo.terminate(); //explicit termination method
}`
</code></pre>
    </section>
    <footer class="post-footer">
      <section class="author">
    <h4>John Doe</h4>
    <p>作为挨踢业的伪设计狮伪技术牛 搬过砖也种过地：爱看、爱听、爱玩儿、爱折腾、机械水电、泥瓦木匠啥都来</p>
</section>
      <section class="share">
    <h4>Share this post</h4>
    <a class="icon-sina-weibo" href="http://v.t.sina.com.cn/share/share.php?title=作为挨踢业的伪设计狮伪技术牛 搬过砖也种过地：爱看、爱听、爱玩儿、爱折腾、机械水电、泥瓦木匠啥都来 ?url=http://yoursite.com/2017/03/15/EffectiveJAVA2/" target="_blank">
        <span class="hidden">weibo</span>
    </a>
    <a class="icon-twitter" href="http://twitter.com/share?url=http://yoursite.com/2017/03/15/EffectiveJAVA2/"
       onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
        <span class="hidden">Twitter</span>
    </a>
    <a class="icon-facebook" href="https://www.facebook.com/sharer/sharer.php?u=http://yoursite.com/2017/03/15/EffectiveJAVA2/"
       onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
        <span class="hidden">Facebook</span>
    </a>
    <a class="icon-google-plus" href="https://plus.google.com/share?url=http://yoursite.com/2017/03/15/EffectiveJAVA2/"
       onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
        <span class="hidden">Google+</span>
    </a>
</section>

    </footer>
  </article>
  <nav class="pagination" role="pagination">
    
    <a class="newer-posts" href="/2017/10/16/Git-Study/">
        ← Git Study
    </a>
    
    <span class="icon-logo">•</span>
    
    <a class="older-posts" href="/2017/01/08/如何做好公正/">
        公正 →
    </a>
    
</nav>

  <div id="comment" class="comments-area">
    <h4 class="title"><a href="#disqus_comments" name="disqus_comments">Comments</a></h4>
    
</div>

</main>


      
<footer class="site-footer">
  
  <div class="inner">
     <section class="copyright">All content copyright <a href="/">Hexo</a> &copy; 2014 &bull; All rights reserved.</section>
     <section class="poweredby">Proudly published with <a class="icon-ghost" href="http://zespia.tw/hexo/">Hexo</a></section>
  </div>
</footer>

      <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>

<script type="text/javascript" src="/js/jquery.fitvids.js"></script>
<script type="text/javascript" src="/js/index.js"></script>
<script type="text/javascript" src="/js/menu.js"></script>





  </div>
</div>

<nav  class="outer-nav top horizontal">

          <a class="icon-home"  href="/"><span>Home</span></a>

          <a class="icon-news"  href="/archive"><span>Archive</span></a>

          <a class="icon-image"  href="/images"><span>Images</span></a>

          <a class="icon-wiki"  href="/wiki/2014-10-28-wiki/"><span>Wiki</span></a>

          <a class="icon-Favorites"  href="/favorites"><span>Favorites</span></a>

          <a class="icon-mail"  href="/about/2014-09-11-mabao/"><span>Contact</span></a>

</nav>

</div>
</body>
</html>
